<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10 Pilihan Vertikal Modern dengan Background Malam dan Meteor Merah</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            min-height: 100vh;
            padding: 20px;
            color: white;
            position: relative;
            overflow-y: auto;
            background: #0a0a1a;
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transition: opacity 1s ease;
        }

        .canvas-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .canvas-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .canvas-container.clickable {
            z-index: 10; /* Membuat container canvas berada di atas saat dapat diklik */
        }

        #meteor-canvas, #particle-canvas {
            width: 100%;
            height: 100%;
        }

        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            position: relative;
            z-index: 1;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .container.show {
            display: block;
            opacity: 1;
        }

        .container.hidden {
            pointer-events: none;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            color: white;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease forwards;
            opacity: 0;
            cursor: pointer;
        }

        .card:hover {
            transform: translateX(10px) scale(1.05);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
        }

        .card-icon {
            font-size: 2rem;
            color: #ff6b6b;
        }

        .card-content {
            flex: 1;
        }

        .card h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .card p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }

        .show-button, .hide-button, .expert-button, .explore-language-button, 
        .toggle-time-button, .hide-buttons-button, .toggle-theme-button {
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            animation: pulse 1.5s infinite;
        }

        .show-button {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            z-index: 2;
        }

        .show-button:hover {
            background: linear-gradient(45deg, #ff8e53, #ff6b6b);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.8);
            transform: translateX(-50%) scale(1.05);
        }

        .expert-button {
            position: fixed;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(90deg, #ff5e62, #f09819);
            z-index: 2;
        }

        .expert-button:hover {
            transform: translateY(-50%) scale(1.1);
        }

        .hide-button {
            display: none;
            margin: 20px auto 0;
            background: linear-gradient(45deg, #ff4444, #ff6666);
            max-width: 200px;
            z-index: 1;
        }

        .hide-button.show {
            display: block;
        }

        .hide-button:hover {
            background: linear-gradient(45deg, #ff6666, #ff4444);
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.8);
            transform: scale(1.05);
        }

        .explore-language-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(90deg, #ff5e62, #f09819);
            z-index: 2;
        }

        .explore-language-button:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .toggle-time-button {
            position: fixed;
            bottom: 20px;
            right: 40px;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            z-index: 2;
        }

        .toggle-time-button:hover {
            transform: scale(1.1);
        }

        .hide-buttons-button {
            position: fixed;
            bottom: 80px;
            right: 40px;
            background: linear-gradient(90deg, #ff758c, #ff7eb3);
            z-index: 2;
        }

        .hide-buttons-button:hover {
            transform: scale(1.1);
        }

        .toggle-theme-button {
            position: fixed;
            bottom: 140px;
            right: 40px;
            background: linear-gradient(90deg, #6b48ff, #00ddeb);
            z-index: 2;
        }

        .toggle-theme-button:hover {
            transform: scale(1.1);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.5); }
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            .card { flex-direction: column; text-align: center; }
            .card-icon { margin-bottom: 10px; }
            .show-button, .hide-button { padding: 10px 20px; font-size: 1rem; }
            .expert-button, .explore-language-button, .toggle-time-button, 
            .hide-buttons-button, .toggle-theme-button { right: 20px; padding: 8px 16px; font-size: 14px; }
        }

        @media (max-width: 480px) {
            .card h2 { font-size: 1.2rem; }
            .card p { font-size: 0.8rem; }
            .show-button, .hide-button { padding: 8px 15px; font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <div class="canvas-container visible" id="meteor-container">
        <canvas id="meteor-canvas"></canvas>
    </div>
    <div class="canvas-container hidden" id="particle-container">
        <canvas id="particle-canvas"></canvas>
    </div>

    <button class="show-button" id="show-button">Explore Task</button>
    <button class="expert-button" id="expert-button">Expert Question</button>
    <div class="container" id="content-container"></div>
    <button class="hide-button" id="hide-button">Hide Content</button>
    <button class="explore-language-button" id="explore-language-button">Explore Language</button>
    <button class="hide-buttons-button" id="hide-buttons-button">Hide Buttons</button>
    <button class="toggle-time-button" id="toggle-time-button">Enable Time Transition</button>
    <button class="toggle-theme-button" id="toggle-theme-button">Switch to Particle Theme</button>

    <script>
        // Data untuk kartu dinamis
        const cardData = [
            { icon: "ðŸ“", title: "praktek pemrograman terstruktur", desc: "semester 2", url: "https://ekz121.github.io/pemrograman-terstruktur/" },
            { icon: "ðŸ“‚", title: "praktek pemrograman web dasar", desc: "semester 2", url: "https://ekz121.github.io/pemrograman-web-dasar/" },
            { icon: "ðŸ“‚", title: "prosedur sebelum memulai", desc: "semester 2", url: "https://ekz121.github.io/halaman-sebelum-memulai/" }
        ];

        // Membuat kartu secara dinamis
        const contentContainer = document.getElementById('content-container');
        cardData.forEach(data => {
            const card = document.createElement('div');
            card.classList.add('card');
            card.setAttribute('data-url', data.url);
            card.innerHTML = `
                <div class="card-icon">${data.icon}</div>
                <div class="card-content">
                    <h2>${data.title}</h2>
                    <p>${data.desc}</p>
                </div>
            `;
            contentContainer.appendChild(card);
        });

        // Fungsi untuk menampilkan/menyembunyikan konten
        function toggleContainers() {
            const container = contentContainer;
            const showButton = document.getElementById('show-button');
            const hideButton = document.getElementById('hide-button');
            if (container.classList.contains('show')) {
                container.classList.remove('show');
                hideButton.classList.remove('show');
                showButton.style.display = 'block';
            } else {
                container.classList.add('show');
                hideButton.classList.add('show');
                showButton.style.display = 'none';
            }
        }

        // Fungsi efek flare (tanpa audio)
        function triggerFlareEffect(targetUrl) {
            const meteorContainer = document.getElementById('meteor-container');
            const particleContainer = document.getElementById('particle-container');
            meteorContainer.classList.add('hidden');
            particleContainer.classList.add('hidden');
            setTimeout(() => {
                window.location.href = targetUrl;
            }, 1000);
        }

        // Variabel untuk melacak apakah tombol sedang disembunyikan
        let buttonsHidden = false;

        // Fungsi untuk menyembunyikan semua tombol dan konten
        function hideAllButtons() {
            buttonsHidden = true;
            document.getElementById('show-button').style.display = 'none';
            document.getElementById('expert-button').style.display = 'none';
            document.getElementById('hide-button').style.display = 'none';
            document.getElementById('explore-language-button').style.display = 'none';
            document.getElementById('toggle-time-button').style.display = 'none';
            document.getElementById('hide-buttons-button').style.display = 'none';
            document.getElementById('toggle-theme-button').style.display = 'none';
            const container = document.getElementById('content-container');
            if (container.classList.contains('show')) {
                container.classList.remove('show');
            }
            container.classList.add('hidden');
            const meteorContainer = document.getElementById('meteor-container');
            const particleContainer = document.getElementById('particle-container');
            if (currentTheme === 'meteor') {
                meteorContainer.classList.add('clickable');
            } else {
                particleContainer.classList.add('clickable');
            }
        }

        // Fungsi untuk menampilkan semua tombol
        function showAllButtons() {
            buttonsHidden = false;
            document.getElementById('show-button').style.display = 'block';
            document.getElementById('expert-button').style.display = 'block';
            document.getElementById('hide-button').style.display = 'none';
            document.getElementById('explore-language-button').style.display = 'block';
            document.getElementById('toggle-time-button').style.display = 'block';
            document.getElementById('hide-buttons-button').style.display = 'block';
            document.getElementById('toggle-theme-button').style.display = 'block';
            const container = document.getElementById('content-container');
            container.classList.remove('hidden');
            const meteorContainer = document.getElementById('meteor-container');
            const particleContainer = document.getElementById('particle-container');
            meteorContainer.classList.remove('clickable');
            particleContainer.classList.remove('clickable');
            const hideButton = document.getElementById('hide-button');
            const showButton = document.getElementById('show-button');
            if (container.classList.contains('show')) {
                hideButton.style.display = 'block';
                showButton.style.display = 'none';
            } else {
                showButton.style.display = 'block';
                hideButton.style.display = 'none';
            }
        }

        // Event listener untuk tombol yang sudah ada
        document.getElementById('show-button').addEventListener('click', toggleContainers);
        document.getElementById('hide-button').addEventListener('click', toggleContainers);
        document.getElementById('expert-button').addEventListener('click', () => triggerFlareEffect('https://ekz121.github.io/comming-soon/'));
        document.getElementById('explore-language-button').addEventListener('click', () => triggerFlareEffect('https://ekz121.github.io/hope/'));
        document.querySelectorAll('.card').forEach(card => {
            card.addEventListener('click', () => triggerFlareEffect(card.getAttribute('data-url')));
        });

        // Event listener untuk menyembunyikan tombol
        document.getElementById('hide-buttons-button').addEventListener('click', hideAllButtons);

        // Event listener untuk klik container canvas agar tombol muncul kembali
        const meteorContainer = document.getElementById('meteor-container');
        const particleContainer = document.getElementById('particle-container');
        meteorContainer.addEventListener('click', (event) => {
            if (buttonsHidden && currentTheme === 'meteor') {
                event.stopPropagation();
                showAllButtons();
            }
        });
        particleContainer.addEventListener('click', (event) => {
            if (buttonsHidden && currentTheme === 'particle') {
                event.stopPropagation();
                showAllButtons();
            }
        });

        // WebGL Setup for Meteor Theme (Original)
        const meteorCanvas = document.getElementById('meteor-canvas');
        const gl = meteorCanvas.getContext('webgl2');
        if (!gl) {
            console.error('WebGL2 tidak didukung di browser ini.');
            document.body.style.background = '#0a0a1a';
        }
        let meteorFrm;
        let particleFrm;

        const vertexSrc = `#version 300 es
            precision highp float;
            in vec4 position;
            void main() { gl_Position = position; }`;

        const fragmtSrcOriginal = `#version 300 es
            precision highp float;
            out vec4 O;
            uniform vec2 resolution;
            uniform float time;
            #define FC gl_FragCoord.xy
            #define T time
            #define R resolution
            #define MN min(R.x,R.y)
            float rnd(vec2 p) {
                p=fract(p*vec2(12.9898,78.233));
                p+=dot(p,p+34.56);
                return fract(p.x*p.y);
            }
            float noise(in vec2 p) {
                vec2 i=floor(p), f=fract(p), u=f*f*(3.-2.*f);
                float a=rnd(i), b=rnd(i+vec2(1,0)), c=rnd(i+vec2(0,1)), d=rnd(i+1.);
                return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);
            }
            float fbm(vec2 p) {
                float t=.0, a=1.; 
                mat2 m=mat2(1.,-.5,.2,1.2);
                for (int i=0; i<5; i++) {
                    t+=a*noise(p);
                    p*=2.*m;
                    a*=.5;
                }
                return t;
            }
            float clouds(vec2 p) {
                float d=1., t=.0;
                for (float i=.0; i<3.; i++) {
                    float a=d*fbm(i*10.+p.x*.2+.2*(1.+i)*p.y+d+i*i+p);
                    t=mix(t,d,a);
                    d=a;
                    p*=2./(i+1.);
                }
                return t;
            }
            void main(void) {
                vec2 uv=(FC-.5*R)/MN, st=uv*vec2(2,1);
                vec3 col=vec3(0);
                float bg=clouds(vec2(st.x+T*.5,-st.y));
                vec3 cloudColor = vec3(bg*0.1, bg*0.05, bg*0.15);
                uv*=1.-.3*(sin(T*.2)*.5+.5);
                for (float i=1.; i<12.; i++) {
                    uv+=.1*cos(i*vec2(.1+.01*i, .8)+i*i+T*.5+.1*uv.x);
                    vec2 p=uv;
                    float d=length(p);
                    vec3 meteorColor = vec3(1.0, 0.1, 0.1);
                    col+=0.0025/d*(cos(sin(i)*meteorColor)+0.5);
                    float b=noise(i+p+bg*1.731);
                    col+=0.004*b/length(max(p,vec2(b*p.x*.02,p.y)));
                    col=mix(col, cloudColor, d*0.8);
                }
                O=vec4(col,1);
            }`;

        const fragmtSrcWithTransition = `#version 300 es
            precision highp float;
            out vec4 O;
            uniform vec2 resolution;
            uniform float time;
            #define FC gl_FragCoord.xy
            #define T time
            #define R resolution
            #define MN min(R.x,R.y)
            float rnd(vec2 p) {
                p = fract(p * vec2(12.9898, 78.233));
                p += dot(p, p + 34.56);
                return fract(p.x * p.y);
            }
            float noise(in vec2 p) {
                vec2 i = floor(p), f = fract(p), u = f * f * (3. - 2. * f);
                float a = rnd(i), b = rnd(i + vec2(1, 0)), c = rnd(i + vec2(0, 1)), d = rnd(i + 1.);
                return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
            }
            float fbm(vec2 p) {
                float t = .0, a = 1.; 
                mat2 m = mat2(1., -.5, .2, 1.2);
                for (int i = 0; i < 5; i++) {
                    t += a * noise(p);
                    p *= 2. * m;
                    a *= .5;
                }
                return t;
            }
            float clouds(vec2 p) {
                float d = 1., t = .0;
                for (float i = .0; i < 3.; i++) {
                    float a = d * fbm(i * 10. + p.x * .2 + .2 * (1. + i) * p.y + d + i * i + p);
                    t = mix(t, d, a);
                    d = a;
                    p *= 2. / (i + 1.);
                }
                return t;
            }
            void main(void) {
                vec2 uv = (FC - .5 * R) / MN, st = uv * vec2(2, 1);
                vec3 col = vec3(0);
                float dayCycle = sin(T * 3.14159265 / 7.0);
                float dayFactor = (dayCycle + 1.0) * 0.5;
                float bg = clouds(vec2(st.x + T * .5, -st.y));
                vec3 nightColor = vec3(bg * 0.05, bg * 0.03, bg * 0.1);
                vec3 morningColor = vec3(bg * 0.3, bg * 0.25, bg * 0.2);
                vec3 cloudColor = mix(nightColor, morningColor, dayFactor);
                float brightness = mix(0.3, 0.7, dayFactor);
                uv *= 1. - .3 * (sin(T * .2) * .5 + .5);
                for (float i = 1.; i < 12.; i++) {
                    uv += .1 * cos(i * vec2(.1 + .01 * i, .8) + i * i + T * .5 + .1 * uv.x);
                    vec2 p = uv;
                    float d = length(p);
                    vec3 meteorColor = vec3(1.0, 0.1, 0.1);
                    col += 0.0025 / d * (cos(sin(i) * meteorColor) + 0.5);
                    float b = noise(i + p + bg * 1.731);
                    col += 0.004 * b / length(max(p, vec2(b * p.x * .02, p.y)));
                    col = mix(col, cloudColor, d * 0.8);
                }
                col *= brightness;
                O = vec4(col, 1);
            }`;

        const vertices = [-1, 1, -1, -1, 1, 1, 1, -1];
        let program, vs, fs, buffer;
        let useTransition = false;
        let currentTheme = 'meteor';

        function resize() {
            const { innerWidth: width, innerHeight: height } = window;
            meteorCanvas.width = width;
            meteorCanvas.height = height;
            particleCanvas.width = width;
            particleCanvas.height = height;
            gl.viewport(0, 0, width, height);
            if (currentTheme === 'particle') {
                createParticles();
            }
        }

        function compile(shader, source) {
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(shader));
        }

        function setupShader(fragSource) {
            if (program) {
                gl.deleteProgram(program);
            }
            if (fs) {
                gl.deleteShader(fs);
            }
            vs = gl.createShader(gl.VERTEX_SHADER);
            fs = gl.createShader(gl.FRAGMENT_SHADER);
            compile(vs, vertexSrc);
            compile(fs, fragSource);
            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(program));
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            const position = gl.getAttribLocation(program, "position");
            gl.enableVertexAttribArray(position);
            gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
            program.resolution = gl.getUniformLocation(program, "resolution");
            program.time = gl.getUniformLocation(program, "time");
        }

        function renderMeteor(now) {
            if (currentTheme === 'meteor') {
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.uniform2f(program.resolution, meteorCanvas.width, meteorCanvas.height);
                gl.uniform1f(program.time, now * 1e-3);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
            meteorFrm = requestAnimationFrame(renderMeteor);
        }

        function initMeteor() {
            resize();
            setupShader(fragmtSrcOriginal);
            meteorContainer.classList.remove('hidden');
            particleContainer.classList.add('hidden');
            renderMeteor(0);
            window.onresize = resize;
        }

        document.getElementById('toggle-time-button').addEventListener('click', () => {
            if (currentTheme === 'meteor') {
                useTransition = !useTransition;
                const newShader = useTransition ? fragmtSrcWithTransition : fragmtSrcOriginal;
                setupShader(newShader);
                document.getElementById('toggle-time-button').textContent = useTransition ? "Disable Time Transition" : "Enable Time Transition";
            }
        });

        // Particle Theme Setup
        const particleCanvas = document.getElementById('particle-canvas');
        const ctx = particleCanvas.getContext('2d');

        const particles = [];
        const fireworkParticles = [];
        const dustParticles = [];
        const ripples = [];
        const techRipples = [];

        const mouse = (() => {
            let state = { x: null, y: null };
            return {
                get x() { return state.x; },
                get y() { return state.y; },
                set({ x, y }) { state = { x, y }; },
                reset() { state = { x: null, y: null }; }
            };
        })();

        let backgroundHue = 0;
        let frameCount = 0;
        let autoDrift = true;

        function adjustParticleCount() {
            const particleConfig = {
                heightConditions: [200, 300, 400, 500, 600],
                widthConditions: [450, 600, 900, 1200, 1600],
                particlesForHeight: [40, 60, 70, 90, 110],
                particlesForWidth: [40, 50, 70, 90, 110]
            };

            let numParticles = 130;
            for (let i = 0; i < particleConfig.heightConditions.length; i++) {
                if (particleCanvas.height < particleConfig.heightConditions[i]) {
                    numParticles = particleConfig.particlesForHeight[i];
                    break;
                }
            }
            for (let i = 0; i < particleConfig.widthConditions.length; i++) {
                if (particleCanvas.width < particleConfig.widthConditions[i]) {
                    numParticles = Math.min(numParticles, particleConfig.particlesForWidth[i]);
                    break;
                }
            }
            return numParticles;
        }

        class Particle {
            constructor(x, y, isFirework = false) {
                const baseSpeed = isFirework ? Math.random() * 2 + 1 : Math.random() * 0.5 + 0.3;
                Object.assign(this, {
                    isFirework,
                    x,
                    y,
                    vx: Math.cos(Math.random() * Math.PI * 2) * baseSpeed,
                    vy: Math.sin(Math.random() * Math.PI * 2) * baseSpeed,
                    size: isFirework ? Math.random() * 2 + 2 : Math.random() * 3 + 1,
                    hue: Math.random() * 360,
                    alpha: 1,
                    sizeDirection: Math.random() < 0.5 ? -1 : 1,
                    trail: []
                });
            }

            update(mouse) {
                const dist = mouse.x !== null ? (mouse.x - this.x) ** 2 + (mouse.y - this.y) ** 2 : 0;
                if (!this.isFirework) {
                    const force = dist && dist < 22500 ? (22500 - dist) / 22500 : 0;
                    if (mouse.x === null && autoDrift) {
                        this.vx += (Math.random() - 0.5) * 0.03;
                        this.vy += (Math.random() - 0.5) * 0.03;
                    }
                    if (dist) {
                        const sqrtDist = Math.sqrt(dist);
                        this.vx += ((mouse.x - this.x) / sqrtDist) * force * 0.1;
                        this.vy += ((mouse.y - this.y) / sqrtDist) * force * 0.1;
                    }
                    this.vx *= mouse.x !== null ? 0.99 : 0.998;
                    this.vy *= mouse.x !== null ? 0.99 : 0.998;
                } else {
                    this.alpha -= 0.02;
                }
                this.x += this.vx;
                this.y += this.vy;
                if (this.x <= 0 || this.x >= particleCanvas.width - 1) this.vx *= -0.9;
                if (this.y < 0 || this.y > particleCanvas.height) this.vy *= -0.9;
                this.size += this.sizeDirection * 0.1;
                if (this.size > 4 || this.size < 1) this.sizeDirection *= -1;
                this.hue = (this.hue + 0.3) % 360;
                if (frameCount % 2 === 0 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
                    this.trail.push({ x: this.x, y: this.y, hue: this.hue, alpha: this.alpha });
                    if (this.trail.length > 15) this.trail.shift();
                }
            }

            draw(ctx) {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `hsla(${this.hue}, 80%, 60%, ${Math.max(this.alpha, 0)})`);
                gradient.addColorStop(1, `hsla(${this.hue + 30}, 80%, 30%, ${Math.max(this.alpha, 0)})`);
                ctx.fillStyle = gradient;
                ctx.shadowBlur = particleCanvas.width > 900 ? 10 : 0;
                ctx.shadowColor = `hsl(${this.hue}, 80%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const { x: x1, y: y1, hue: h1, alpha: a1 } = this.trail[i];
                        const { x: x2, y: y2 } = this.trail[i + 1];
                        ctx.strokeStyle = `hsla(${h1}, 80%, 60%, ${Math.max(a1, 0)})`;
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.stroke();
                }
            }

            isDead() {
                return this.isFirework && this.alpha <= 0;
            }
        }

        class DustParticle {
            constructor() {
                Object.assign(this, {
                    x: Math.random() * particleCanvas.width,
                    y: Math.random() * particleCanvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    hue: Math.random() * 360,
                    vx: (Math.random() - 0.5) * 0.05,
                    vy: (Math.random() - 0.5) * 0.05
                });
            }

            update() {
                this.x = (this.x + this.vx + particleCanvas.width) % particleCanvas.width;
                this.y = (this.y + this.vy + particleCanvas.height) % particleCanvas.height;
                this.hue = (this.hue + 0.1) % 360;
            }

            draw(ctx) {
                ctx.fillStyle = `hsla(${this.hue}, 30%, 70%, 0.3)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Ripple {
            constructor(x, y, hue = 0, maxRadius = 30) {
                Object.assign(this, { x, y, radius: 0, maxRadius, alpha: 0.5, hue });
            }

            update() {
                this.radius += 1.5;
                this.alpha -= 0.01;
                this.hue = (this.hue + 5) % 360;
            }

            draw(ctx) {
                ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${this.alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            isDone() {
                return this.alpha <= 0;
            }
        }

        function createParticles() {
            particles.length = 0;
            dustParticles.length = 0;
            const numParticles = adjustParticleCount();
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle(Math.random() * particleCanvas.width, Math.random() * particleCanvas.height));
            }
            for (let i = 0; i < 200; i++) {
                dustParticles.push(new DustParticle());
            }
        }

        function drawBackground() {
            backgroundHue = (backgroundHue + 0.2) % 360;
            const gradient = ctx.createLinearGradient(0, 0, 0, particleCanvas.height);
            gradient.addColorStop(0, `hsl(${backgroundHue}, 40%, 15%)`);
            gradient.addColorStop(1, `hsl(${(backgroundHue + 120) % 360}, 40%, 25%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
        }

        function connectParticles() {
            const gridSize = 120;
            const grid = new Map();
            particles.forEach((p) => {
                const key = `${Math.floor(p.x / gridSize)},${Math.floor(p.y / gridSize)}`;
                if (!grid.has(key)) grid.set(key, []);
                grid.get(key).push(p);
            });
            ctx.lineWidth = 1.5;
            particles.forEach((p) => {
                const gridX = Math.floor(p.x / gridSize);
                const gridY = Math.floor(p.y / gridSize);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${gridX + dx},${gridY + dy}`;
                        if (grid.has(key)) {
                            grid.get(key).forEach((neighbor) => {
                                if (neighbor !== p) {
                                    const diffX = neighbor.x - p.x;
                                    const diffY = neighbor.y - p.y;
                                    const dist = diffX * diffX + diffY * diffY;
                                    if (dist < 10000) {
                                        ctx.strokeStyle = `hsla(${(p.hue + neighbor.hue) / 2}, 80%, 60%, ${1 - Math.sqrt(dist) / 100})`;
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(neighbor.x, neighbor.y);
                                        ctx.stroke();
                                    }
                                }
                            });
                        }
                    }
                }
            });
        }

        function animateParticles() {
            if (currentTheme === 'particle') {
                drawBackground();
                [dustParticles, particles, ripples, techRipples, fireworkParticles].forEach((arr) => {
                    for (let i = arr.length - 1; i >= 0; i--) {
                        const obj = arr[i];
                        obj.update(mouse);
                        obj.draw(ctx);
                        if (obj.isDone?.() || obj.isDead?.()) arr.splice(i, 1);
                    }
                });
                connectParticles();
                frameCount++;
            }
            particleFrm = requestAnimationFrame(animateParticles);
        }

        particleCanvas.addEventListener("mousemove", (e) => {
            const rect = particleCanvas.getBoundingClientRect();
            mouse.set({ x: e.clientX - rect.left, y: e.clientY - rect.top });
            techRipples.push(new Ripple(mouse.x, mouse.y));
            autoDrift = false;
        });

        particleCanvas.addEventListener("mouseleave", () => {
            mouse.reset();
            autoDrift = true;
        });

        particleCanvas.addEventListener("click", (e) => {
            const rect = particleCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            ripples.push(new Ripple(clickX, clickY, 0, 60));
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                const particle = new Particle(clickX, clickY, true);
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                fireworkParticles.push(particle);
            }
        });

        // Toggle Theme
        document.getElementById('toggle-theme-button').addEventListener('click', () => {
            if (currentTheme === 'meteor') {
                currentTheme = 'particle';
                meteorContainer.classList.add('hidden');
                particleContainer.classList.remove('hidden');
                document.getElementById('toggle-theme-button').textContent = "Switch to Meteor Theme";
                if (meteorFrm) {
                    cancelAnimationFrame(meteorFrm);
                }
                createParticles();
                animateParticles();
            } else {
                currentTheme = 'meteor';
                particleContainer.classList.add('hidden');
                meteorContainer.classList.remove('hidden');
                document.getElementById('toggle-theme-button').textContent = "Switch to Particle Theme";
                if (particleFrm) {
                    cancelAnimationFrame(particleFrm);
                }
                renderMeteor(0);
            }
        });

        // Initialize Meteor Theme
        initMeteor();

        // Event handlers for page visibility
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                if (currentTheme === 'meteor') {
                    meteorContainer.classList.remove('hidden');
                    if (!meteorFrm) renderMeteor(0);
                } else {
                    particleContainer.classList.remove('hidden');
                    if (!particleFrm) animateParticles();
                }
            }
        });

        window.addEventListener('pagehide', () => {
            if (meteorFrm) {
                cancelAnimationFrame(meteorFrm);
                meteorFrm = null;
            }
            if (particleFrm) {
                cancelAnimationFrame(particleFrm);
                particleFrm = null;
            }
        });
    </script>
</body>
</html>
